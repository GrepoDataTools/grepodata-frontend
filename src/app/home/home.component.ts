import {Component, ElementRef, OnInit, Renderer2, ViewChild, ViewEncapsulation} from '@angular/core';
import {LocalStorageService} from '../shared/services/local-storage.service';
import {WorldService} from '../shared/services/world.service';
import {ActivatedRoute, Router} from '@angular/router';
import {MatDialog} from '@angular/material/dialog';
import {Globals} from '../globals';
import {SearchService} from '../shared/services/search.service';
import {environment} from '../../environments/environment';
import {ConquestService} from '../shared/services/conquest.service';
import {PlayerService} from '../shared/services/player.service';
import {AllianceService} from '../shared/services/alliance.service';
import {AllianceOverviewDialogComponent} from '../shared/dialogs/alliance-overview-dialog/alliance-overview-dialog.component';
import {PlayerOverviewDialogComponent} from '../shared/dialogs/player-overview-dialog/player-overview-dialog.component';
import {OverviewDialogComponent} from '../shared/dialogs/overview-dialog/overview-dialog.component';
import {BbScoreboardDialogComponent} from '../shared/dialogs/bb-scoreboard-dialog/bb-scoreboard-dialog.component';
import {ConquestDialog} from '../shared/dialogs/conquest-dialog/conquest.component';
import * as icon from '@fortawesome/free-solid-svg-icons';
import * as moment from 'moment';

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.scss'],
  providers: [LocalStorageService, WorldService, SearchService],
  encapsulation: ViewEncapsulation.None
})
export class HomeComponent implements OnInit {
  @ViewChild('searchPlayerOff', { static: false, read: ElementRef }) searchPlayerOff: ElementRef;
  @ViewChild('searchPlayerDef', { static: false, read: ElementRef }) searchPlayerDef: ElementRef;
  @ViewChild('overviewContainer', { static: false }) overviewContainer: ElementRef;

  // API data
  playerData = '' as any;
  playerDiffs = '' as any;
  allianceData = '' as any;
  allianceChangesData = [] as any;
  data_default: any[];
  worldData = '' as any;

  // Form vars
  icon = icon;
  server: any = 'nl'; // TODO: dynamic default??
  world: any = ''; // TODO: dynamic default??
  worldName = '';
  nextUpdate = '';
  playerInput = '';
  searchResults = [];
  servers = [];
  worlds = [];
  loadingPlayers = false;
  loadingDiffs = true;
  loadingAlliances = false;
  noAllianceData = false;
  noPlayerData = false;
  toggleMore = true;
  hasOverview = true;
  searching = false;
  searchInputting = false;
  mobile = false;
  noticePlayer = '';
  noticeAlliance = '';

  // Datepicker
  minDate = '';
  maxDate = new Date();
  selectedDate = new Date();
  scoreboardDateInfo = '';
  paramsDate = moment().format('YYYY-MM-DD');

  // Debounce
  typingTimer;
  debounceTime = 400;
  usedInput: any;

  env = environment;
  constructor(
    private globals: Globals,
    private playerService: PlayerService,
    private allianceService: AllianceService,
    private conquestService: ConquestService,
    private searchService: SearchService,
    private worldService: WorldService,
    private router: Router,
    private route: ActivatedRoute,
    public dialog: MatDialog,
    private renderer: Renderer2
  ) {
    if (window.screen.width < 560) {
      this.mobile = true;
      this.debounceTime = 750;
    }

    this.server = worldService.getDefaultServer();

    // Load scoreboard using params. if no params are supplied, they will be generated by backend
    this.route.queryParams.subscribe(params => {
      if (params.world != undefined && params.date != undefined)
        this.router.navigate(['/points/' + params.world + '/' + params.date]);
      else if (params.world != undefined) this.router.navigate(['/points/' + params.world]);
    });
    this.route.params.subscribe(params => this.load(params));
  }

  ngOnInit() {
    this.worldService.getWorlds().then(response => this.loadWorlds(response));
  }

  setInputValue(val) {
    this.playerInput = val;
    if (this.searchPlayerOff) this.searchPlayerOff.nativeElement.value = val;
    if (this.searchPlayerDef) this.searchPlayerDef.nativeElement.value = val;
  }

  clearSearch() {
    this.setInputValue('');
    this.searchResults = [];
  }

  filterKeyup($event) {
    if (typeof $event != 'undefined') {
      this.searchInputting = true;
      this.usedInput = $event.target;
      this.setInputValue($event.target.value);
    }

    clearTimeout(this.typingTimer);
    const that = this;
    this.typingTimer = setTimeout(function() {
      that.filterEvent();
    }, this.debounceTime);
  }

  filterEvent() {
    this.searchInputting = false;
    if (this.playerInput.length > 2) {
      this.searching = true;
      this.searchService
        .searchPlayers(this.playerInput, 0, 7, this.server, this.world, false, null, null, true, '')
        .subscribe(
          response => this.renderSearchResults(response),
          error => {
            this.searchResults = [];
            this.searching = false;
            if (this.usedInput) {
              setTimeout(() => this.usedInput.focus(), 0);
            }
          }
        );
    }
  }

  renderSearchResults(response) {
    if (response.success == true) {
      this.searchResults = response.results;
    } else {
      this.searchResults = [];
    }

    const that = this;
    this.searchResults.forEach(function(i) {
      Object.keys(that.playerData.att).forEach(function(j) {
        if (that.playerData.att[j].i == i.id) {
          i.att_rank_scoreboard = +j + 1;
        }
      });
      Object.keys(that.playerData.def).forEach(function(j) {
        if (that.playerData.def[j].i == i.id) {
          i.def_rank_scoreboard = +j + 1;
        }
      });
    });

    this.searching = false;
    if (this.usedInput) {
      setTimeout(() => this.usedInput.focus(), 10);
    }
  }

  refresh() {
    const params = { world: this.world };
    this.load(params);
  }

  load(params) {
    // Save params
    if (params.date) {
      this.paramsDate = params.date;
    }
    if (typeof params.world != 'undefined') {
      this.world = params.world;
      this.server = this.world.substr(0, 2);
      this.globals.set_active_world(this.world);
      this.globals.set_active_server(this.server);
    } else if (this.server != '' && this.world != '' && this.server != this.world.substr(0, 2)) {
      this.world = '';
    } else if (this.globals.get_active_world()) {
      this.world = this.globals.get_active_world();
      this.server = this.world.substr(0, 2);
    }

    this.loadingPlayers = true;
    this.loadingDiffs = true;
    this.playerDiffs = '';
    this.searchResults = [];
    this.searching = false;
    this.setInputValue('');
    this.playerService
      .loadScoreboard(this.world, params.date, this.server)
      .subscribe(
        response => this.renderPlayerScoreboard(response, params.date),
        error => this.renderPlayerScoreboard(null, params.date)
      ).add(() => this.loadingPlayers = false);
  }

  loadPlayers() {
    this.loadingPlayers = true;
    this.loadingDiffs = true;

    this.playerService
      .loadScoreboard(this.world, this.paramsDate, this.server)
      .subscribe(
        response => this.renderPlayerScoreboard(response, this.paramsDate),
        error => this.renderPlayerScoreboard(null, this.paramsDate)
      ).add(() => this.loadingPlayers = false);
  }

  loadAlliances() {
    this.loadingAlliances = true;
    this.allianceService
      .loadScoreboard(this.world, this.paramsDate, this.server)
      .subscribe(
        response => this.renderAllianceScoreboard(response, this.paramsDate),
        error => this.renderAllianceScoreboard(null, this.paramsDate)
      );

    this.allianceService
      .loadChanges(this.world, this.paramsDate, this.server, 0, 22)
      .subscribe(
        response => this.renderAllianceChanges(response, this.paramsDate),
        error => this.renderAllianceChanges(null, this.paramsDate)
      );
  }

  loadWorlds(worldData) {
    this.worldData = worldData;
    this.servers = [];
    this.worlds = [];
    for (const i of this.worldData) {
      this.servers.push((i as any).server);
      if ((i as any).server === this.server) {
        for (const w of (i as any).worlds) {
          this.worlds.push(w);
          if (w.id === this.world) this.worldName = w.name;
        }
      }
    }
  }

  setWorld(event) {
    this.globals.set_active_world(event);
    this.globals.set_active_server(event.substr(0, 2));
    if (this.nextUpdate == '') {
      this.router.navigate(['/points/' + event + '/' + this.selectedDate]);
    } else {
      this.router.navigate(['/points/' + event]);
    }
  }
  setDate(event) {
    const dateString =
      event.getFullYear() + '-' + ('0' + (event.getMonth() + 1)).slice(-2) + '-' + ('0' + event.getDate()).slice(-2);
    this.router.navigate(['/points/' + this.world + '/' + dateString]);
  }
  prevDay() {
    const today = new Date(this.selectedDate);
    const tomorrow = new Date(this.selectedDate);
    tomorrow.setDate(today.getDate() - 1);
    this.router.navigate([
      '/points/' +
        this.world +
        '/' +
        (tomorrow.getFullYear().toString() +
          '-' +
          ('0' + (tomorrow.getMonth() + 1)).slice(-2) +
          '-' +
          ('0' + tomorrow.getDate()).slice(-2))
    ]);
  }
  nextDay() {
    const today = new Date(this.selectedDate);
    const tomorrow = new Date(this.selectedDate);
    tomorrow.setDate(today.getDate() + 1);
    this.router.navigate([
      '/points/' +
        this.world +
        '/' +
        (tomorrow.getFullYear().toString() +
          '-' +
          ('0' + (tomorrow.getMonth() + 1)).slice(-2) +
          '-' +
          ('0' + tomorrow.getDate()).slice(-2))
    ]);
  }
  today() {
    this.router.navigate(['/points/' + this.world]);
  }

  updateWorlds(event) {
    this.server = event;
    this.loadWorlds(this.worldData);
    this.load([]);
  }

  renderPlayerScoreboard(json, date) {
    if (json == null) {
      this.noticePlayer = 'We found no player scoreboard for ' + this.world + ' on ' + date;
      this.noPlayerData = true;
    } else {
      // Check response date
      if (date != undefined && date != json.date)
        this.noticePlayer =
          'Unable to find player scoreboard for ' +
          this.world +
          ' on ' +
          date +
          '; showing today\'s scoreboard instead.';
      else this.noticePlayer = '';

      // Update scoreboard form and data
      this.playerData = json;
      // console.log(json.overview);
      this.data_default = json.overview;
      this.minDate = json.minDate;
      this.selectedDate = json.date;
      this.world = json.world;
      this.server = json.world.substring(0, 2);
      this.globals.set_active_world(this.world);
      this.globals.set_active_server(this.server);

      if (json.date) {
        const date = new Date(json.date);
        const limit = new Date();
        limit.setMonth(limit.getMonth() - 1);
        this.hasOverview = limit <= date;
      } else {
        this.hasOverview = false;
      }

      // Date status
      if (json.allowCache == false) {
        // Today!
        this.scoreboardDateInfo = 'today before ' + json.time;
        if (!json.nextUpdate.includes('after')) {
          this.nextUpdate = 'Next update expected in ' + json.nextUpdate;
        } else {
          this.nextUpdate = 'Next update imminent';
        }

        this.loadPlayerDiffs();
      } else {
        this.scoreboardDateInfo = 'on ' + json.date;
        this.nextUpdate = '';
      }

      this.loadWorlds(this.worldData);
    }
    this.loadingPlayers = false;
  }

  onOverviewSelect(event) {
    if (this.hasOverview) {
      this.openOverviewdialog(event.series);
    }
  }

  openPlayerOverview(id, name) {
    this.openPlayerOverviewdialog(id, name);
  }

  openAllianceOverview(id, name) {
    this.openAllianceOverviewdialog(id, name);
  }

  loadPlayerDiffs() {
    this.playerService.loadDifferences(this.world).subscribe(
      response => {
        console.log(response);
        this.playerDiffs = response;
        this.loadingDiffs = false;
      },
      error => {
        this.loadingDiffs = true;
      }
    );
  }

  renderAllianceScoreboard(json, date) {
    if (json == null) {
      this.noticeAlliance = 'We found no alliance scoreboard for ' + this.world + ' on ' + date;
      this.allianceData = '';
      this.noAllianceData = true;
    } else {
      if (date != undefined && date != json.date)
        this.noticeAlliance =
          'Unable to find alliance scoreboard for ' +
          this.world +
          ' on ' +
          date +
          '; showing ' +
          json.date +
          ' instead.';
      else this.noticeAlliance = '';
      this.allianceData = json;
      this.noAllianceData = false;
    }
    this.loadingAlliances = false;
  }

  renderAllianceChanges(json, date) {
    if (json == null || json.items == undefined) {
      this.allianceChangesData = '';
    } else {
      this.allianceChangesData = json.items;
    }
  }

  public openBBdialog(type) {
    const dataBB = {
      data: {},
      world: this.world,
      worldName: this.worldName,
      date: this.selectedDate,
      dateInfo: this.scoreboardDateInfo
    };
    if (type == 'players_att') {
      dataBB.data = this.playerData.att;
    } else if (type == 'players_def') {
      dataBB.data = this.playerData.def;
    } else if (type == 'players_con') {
      dataBB.data = this.playerData.con;
    } else if (type == 'players_los') {
      dataBB.data = this.playerData.los;
    } else if (type == 'alliances_att') {
      dataBB.data = this.allianceData.att;
    } else if (type == 'alliances_def') {
      dataBB.data = this.allianceData.def;
    } else if (type == 'alliances_con') {
      dataBB.data = this.allianceData.con;
    } else if (type == 'alliances_los') {
      dataBB.data = this.allianceData.los;
    } else {
      return false;
    }

    const dialogRef = this.dialog.open(BbScoreboardDialogComponent, {
      autoFocus: false,
      data: {
        dataBB,
        type
      }
    });

    dialogRef.afterClosed().subscribe(result => {});
  }

  public openOverviewdialog(hour) {
    const dialogRef = this.dialog.open(OverviewDialogComponent, {
      autoFocus: false,
      data: {
        world: this.world,
        date: this.selectedDate.toString(),
        hour
      }
    });
    dialogRef.afterClosed().subscribe(result => {});
  }

  public openPlayerOverviewdialog(id, name) {
    const dialogRef = this.dialog.open(PlayerOverviewDialogComponent, {
      autoFocus: false,
      data: {
        world: this.world,
        date: this.selectedDate.toString(),
        id,
        name
      }
    });
    dialogRef.afterClosed().subscribe(result => {});
  }

  public openAllianceOverviewdialog(id, name) {
    const dialogRef = this.dialog.open(AllianceOverviewDialogComponent, {
      autoFocus: false,
      data: {
        world: this.world,
        date: this.selectedDate.toString(),
        id,
        name
      }
    });
    dialogRef.afterClosed().subscribe(result => {});
  }

  showConquests(type, id, name) {
    this.dialog.open(ConquestDialog, {
      autoFocus: false,
      data: {
        filters: {
          id,
          type,
          world: this.world,
          date: this.selectedDate
        },
        name
      }
    });
  }
}
